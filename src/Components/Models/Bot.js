/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useMemo, useRef, useState } from "react";
import { Html, useGLTF, useAnimations } from "@react-three/drei";
import { socket, CLIENTID, SendAcknowledgement } from "../../Connections/socket";
import { clone as Clone } from 'three/examples/jsm/utils/SkeletonUtils';
import { useGraph, useFrame } from "@react-three/fiber";

import { CycleRaycast } from '@react-three/drei'
// function 

const SlopeCos = ( angle ) => {
	return -1*Math.sin(angle);
}

const Styles = {
	Label: {
		transform: 'translate3d(-50%, -125px, 0px)',
		padding:'0px 2px',borderRadius:'10%',
		backgroundColor:'InfoBackground',
		color:'InfoText',fontFamily:'monospace',
		WebkitUserSelect:'none',
		fontSize:'0.5em'
		
	}
}

let num = 0;

export default function Model({ ...props }) {
	const playerModel = useRef();

	const { scene, materials, animations } = useGLTF("/BotModel.gltf");
	const clone = useMemo(() => Clone(scene), [scene]);
	const { nodes } = useGraph(clone);
	const { actions } = useAnimations(animations, playerModel);

	const position = useRef((props.player == 2 && props.p2initpos!=null) ? ([props.p2initpos[0], props.p2initpos[1], props.p2initpos[2]+props.displacementZ]) : [0, 1.4, 0.09]);
	const [ keyPress, setKeyPress ] = useState(null);
	const k = useRef(null);
	const [ animationName, setAnimationName ] = useState(null);

	useEffect(() => {
		setAnimationName('standing');
		console.log(actions)
		actions.standing.play();

		if(props.player == 2){
			if(props.p2initpos != null && props.p2initpos.length != 0){
				console.log(props.p2initpos);
			}
		}
		return () => {
			console.log('ran once');
		};
	}, []);

	useEffect( () => {
		if(props.player == 1){
			document.addEventListener('keydown', e => {
				//emit to same room
				// no key is pressed
				if(! ['w', 's', 'a', 'd'].includes(e.key))
					return;

				if(k.current == null){
					k.current = e.key;
					//stop emit signals for now
					socket.emit('player-move', {CLIENTID:CLIENTID, worldID:props.worldID, key:e.key});
				}
				
			});
			document.addEventListener('keyup', e => {
				//key is already pressed
				if(k.current != null){
					k.current = null;
					
					//stop emit signal for now
					socket.emit('player-move', {CLIENTID:CLIENTID, worldID:props.worldID, key:null});
				}
			})
		}else if(props.player == 2){
			socket.on('player-move', e => {
				// console.log('player moved', e);
				if(e.CLIENTID != CLIENTID){
					if(k.current != e.key){
						k.current = e.key;
					}
				}
			})
		}
	return () => {};
	}, [...position.current]);

	useFrame(() => {
		if(k.current == null){
			if( animationName && animationName != 'standing'){
				actions.standing.play();
				actions[animationName].stop();
				setAnimationName('standing');
			}
			return;
		}

		if( animationName && animationName != 'walkForward'){
			actions.walkForward.play();
			actions[animationName].stop();
			setAnimationName('walkForward')
		}

		if(Math.abs(playerModel.current.rotation.z) >= 2*Math.PI)
			playerModel.current.rotation.z = 0;
			

		switch (k.current) {
			case 'w':
				position.current[2]-=0.15;
				playerModel.current.position.z-=0.15;
				
				// rotation logic
				if( Math.cos( playerModel.current.rotation.z ) != -1 ){
					if( SlopeCos( playerModel.current.rotation.z ) > 0 ){
						playerModel.current.rotation.z -= 0.1;
					}else if( SlopeCos( playerModel.current.rotation.z ) <= 0 ){
						playerModel.current.rotation.z += 0.1;
					}
				}	
				break;
			case 's':
				position.current[2]+=0.15;
				playerModel.current.position.z+=0.15;

				// rotation logic

				if( Math.cos( playerModel.current.rotation.z ) != 1 ){
					if( SlopeCos( playerModel.current.rotation.z ) > 0 ){
						playerModel.current.rotation.z += 0.1;
					}else if( SlopeCos( playerModel.current.rotation.z ) <= 0 ){
						playerModel.current.rotation.z -= 0.1;
					}
				}
				break;
			case 'a':
				position.current[0]-=0.15;
				playerModel.current.position.x-=0.15;
				
				// rotation logic

				if( Math.cos( playerModel.current.rotation.z ) != 0 ){
					if( Math.cos( playerModel.current.rotation.z ) > 0 ){
						playerModel.current.rotation.z += 0.1;
					}else if( Math.cos( playerModel.current.rotation.z ) <= 0 ){
						playerModel.current.rotation.z -= 0.1;
					}
				}

				break;
			case 'd':
				position.current[0]+=0.15;
				playerModel.current.position.x+=0.15;

				// rotation logic

				if( Math.cos( playerModel.current.rotation.z ) != 0 ){
					if( Math.cos( playerModel.current.rotation.z ) > 0 ){
						playerModel.current.rotation.z -= 0.1;
					}else if( Math.cos( playerModel.current.rotation.z ) <= 0 ){
						playerModel.current.rotation.z += 0.1;
					}
				}
				break;
			default:
				break;
		}
	})

	socket.on('second-player-joined', playerID => {
		if(CLIENTID != playerID && props.player  == 1){
			//send acknoedgement to other
			SendAcknowledgement(...position.current, playerID);
		}
	});

	

	return (
		<group position={position.current} rotation={[Math.PI / 2, 0, Math.PI]} ref={playerModel} {...props} dispose={null}>
			<Html zIndexRange={[10, 0]}>
				<div style={Styles.Label}>{CLIENTID}</div>
			</Html>
			<group name="Scene">
				<group name="Armature" scale={0.025}>
					<primitive object={nodes.mixamorigHips} />
						<skinnedMesh
							name="Alpha_Joints"
							geometry={nodes.Alpha_Joints.geometry}
							material={materials.Alpha_Joints_MAT}
							skeleton={nodes.Alpha_Joints.skeleton}
						/>
						<skinnedMesh
							name="Alpha_Surface"
							geometry={nodes.Alpha_Surface.geometry}
							material={materials.Alpha_Body_MAT}
							skeleton={nodes.Alpha_Surface.skeleton}
						/>
				</group>
			</group>
		</group>
	);
}

useGLTF.preload("/BotModel.gltf");